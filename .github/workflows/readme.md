# Challenge API ‚Äî FastAPI on AWS Lambda (Terraform + GitHub Actions)

> Backendzinho enxuto, infra como c√≥digo e deploy sem drama. üòé

## üß≠ Vis√£o geral
Este projeto entrega uma **API FastAPI** rodando em **AWS Lambda**, exposta pelo **API Gateway REST** e protegida por **API Key + Usage Plan**.  
A infra √© criada com **Terraform** (state remoto em **S3** com lock em **DynamoDB**) e o deploy √© autom√°tico via **GitHub Actions** usando **OIDC**.

### Endpoints
- `GET /health` ‚Üí `{"status":"ok"}`
- `GET /hello?name=SeuNome` ‚Üí `{"message":"Hello, SeuNome!"}`  
  > Todos os endpoints pedem `x-api-key: <API_KEY>`

---

## üèóÔ∏è Arquitetura simplificada
```
                +------------------+
                |  GitHub Actions  |
                +---------+--------+
                          |  OIDC (assume role)
                          v
                +-----------------------+
                |   IAM Role (AWS)      |
                +-----------+-----------+
                            |
                            v
                +-----------+-----------+
                |   Terraform (IaC)     |
                |   backend: S3 + DDB   |
                +-----------+-----------+
                            |
                            v
     +----------------------+----------------------+
     |                   AWS                       |
     |                                              |
     |  +------------------+     +----------------+ |
     |  | Lambda           | <-- | API Gateway    | |
     |  | challenge-api    |     | REST (prod)    | |
     |  | FastAPI + Mangum |     |  - ANY /{proxy+}| |
     |  +------------------+     |  - API Key     | |
     |                            +----------------+ |
     +----------------------------------------------+

S3 bucket: challenge-entrevista (state)
DynamoDB table: desafio-tf-locks (state lock)
```

---

## ‚è±Ô∏è Em 60 segundos: como tudo conversa
1. √â dado um` **push** na `main` ‚Üí o **GitHub Action** come√ßa.
2. O Action usa **OIDC** para **assumir uma IAM Role** na AWS (credenciais tempor√°rias, nada de chave fixa).
3. O **Terraform** inicializa com **state no S3** e **lock no DynamoDB**, aplica a infra (Lambda, API Gateway, etc.).
4. Sai no output a **URL da API** e a **API Key** para uso.
5. A Action roda **smoke tests** chamando `/health` e `/hello` com a **API Key**.

---

## üìö Gloss√°rio 
- **ASGI** (Asynchronous Server Gateway Interface) ‚Üí ‚Äúgram√°tica‚Äù moderna pra apps web Python falarem com servidores de forma **ass√≠ncrona** (inclui WebSockets). O **FastAPI** fala ASGI.
- **Mangum** ‚Üí O ‚Äúint√©rprete‚Äù que traduz **API Gateway/Lambda ‚Üî ASGI**. Permite FastAPI rodar dentro da Lambda.
- **OIDC** (OpenID Connect) ‚Üí Jeito seguro do GitHub provar quem ele √© para a AWS e **conseguir credenciais tempor√°rias** sem gravar senha/keys.
- **STS** (Security Token Service) ‚Üí Servi√ßo da AWS que **emite credenciais tempor√°rias** quando a Action assume a Role.
- **Terraform Backend** ‚Üí Onde o **state** do Terraform mora (aqui: **S3**). Sem isso, cada m√°quina teria um state diferente (caos).
- **State Lock** ‚Üí Cadeado no state (aqui: **DynamoDB**) para **evitar dois applys ao mesmo tempo**.
- **API Key** ‚Üí Uma chave simples no header (`x-api-key`) pra controlar quem consome a API.
- **Usage Plan** ‚Üí Regras de **limite de uso** por API Key (quantas req por segundo e por m√™s).

---

## üß∞ Tech stack
- **Linguagem:** Python 3.12
- **Framework:** FastAPI + Mangum (adapter ASGI para Lambda)
- **Infra:** Terraform (AWS provider)
- **AWS:** Lambda, API Gateway REST, S3 (state), DynamoDB (lock), IAM
- **CI/CD:** GitHub Actions com OIDC
- **Empacotamento:** `scripts/package.sh` (gera `package.zip`)

---

## ‚úÖ O que foi implementado
- **Lambda `challenge-api`** (Python 3.12) com FastAPI + Mangum.
- **API Gateway REST** com:
  - Rota `ANY /{proxy+}` e `ANY /` (Lambda Proxy Integration).
  - **API Key** + **Usage Plan** (quota e throttling).
- **Permiss√£o** para o API Gateway invocar a Lambda.
- **Terraform modular**:
  - `modules/lambda-func` ‚Üí fun√ß√£o + IAM m√≠nimo de logs.
  - `modules/apigw-rest` ‚Üí API, m√©todos, integra√ß√µes, stage `prod`, API Key, Usage Plan.
- **Backend do Terraform**: S3 (`challenge-entrevista`) + DynamoDB (`desafio-tf-locks`).
- **Pipeline** (`.github/workflows/deploy.yaml`): empacota, assume role via OIDC, `init/plan/apply`, smoke tests.

---

## üß± Antes de tudo: criar S3 + DynamoDB pro state
Sem isso, o `terraform init` n√£o sabe onde salvar o state.

> Em `us-east-1`, a cria√ß√£o do bucket **n√£o** usa `--create-bucket-configuration`.

```bash
# Vari√°veis (exemplo)
BUCKET="challenge-entrevista"
TABLE="desafio-tf-locks"
REGION="us-east-1"

# 1) Criar bucket S3
if [ "$REGION" = "us-east-1" ]; then
  aws s3api create-bucket --bucket "$BUCKET" --region "$REGION"
else
  aws s3api create-bucket --bucket "$BUCKET" --region "$REGION"     --create-bucket-configuration LocationConstraint="$REGION"
fi

# 2) (recomendado) Habilitar versionamento + criptografia em repouso
aws s3api put-bucket-versioning   --bucket "$BUCKET" --versioning-configuration Status=Enabled

aws s3api put-bucket-encryption   --bucket "$BUCKET"   --server-side-encryption-configuration '{
    "Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]
  }'

# 3) (opcional) For√ßar TLS only
aws s3api put-bucket-policy --bucket "$BUCKET" --policy '{
  "Version":"2012-10-17",
  "Statement":[{
    "Sid":"DenyInsecureTransport",
    "Effect":"Deny",
    "Principal":"*",
    "Action":"s3:*",
    "Resource":[
      "arn:aws:s3:::'"$BUCKET"'",
      "arn:aws:s3:::'"$BUCKET"'/*"
    ],
    "Condition":{"Bool":{"aws:SecureTransport":"false"}}
  }]}'

# 4) Criar tabela DynamoDB para lock
aws dynamodb create-table   --table-name "$TABLE"   --attribute-definitions AttributeName=LockID,AttributeType=S   --key-schema AttributeName=LockID,KeyType=HASH   --billing-mode PAY_PER_REQUEST   --region "$REGION"
```

### Onde coloco esses nomes depois?
- **Local (CLI)** ‚Äî no `terraform init`:
```bash
cd infra
terraform init -reconfigure   -backend-config="bucket=$BUCKET"   -backend-config="key=infra/terraform.tfstate"   -backend-config="region=$REGION"   -backend-config="dynamodb_table=$TABLE"   -backend-config="encrypt=true"
```
- **Pipeline (GitHub Actions)** ‚Äî como **Secrets** do reposit√≥rio:
  - `TF_STATE_BUCKET` = `challenge-entrevista`
  - `TF_STATE_KEY`    = `infra/terraform.tfstate`
  - `TF_STATE_TABLE`  = `desafio-tf-locks`
  - `AWS_REGION`      = `us-east-1`

> Dica: padronize o **key** do state por projeto/ambiente (ex.: `infra/terraform.tfstate`).

---

## üöÄ Como rodar (local + AWS)
### 0) Pr√©-requisitos
- **AWS CLI** autenticado (perfil local) ou GitHub Actions com OIDC.
- **Terraform ‚â• 1.6**.
- **Python 3.12** (para empacotar local).
- **jq** (para smoke tests da pipeline).

### 1) Empacotar a Lambda
```bash
chmod +x scripts/package.sh
./scripts/package.sh   # gera package.zip na raiz do repo
```

### 2) Aplicar infra
```bash
cd infra
terraform plan  -var="region=us-east-1" -var="package_zip=../package.zip"
terraform apply -auto-approve -var="region=us-east-1" -var="package_zip=../package.zip"
```

### 3) Outputs √∫teis
```bash
terraform output -raw api_url
terraform output -raw api_key
```

---

## üß™ Como testar r√°pido
```bash
API_URL=$(terraform -chdir=infra output -raw api_url)
API_KEY=$(terraform -chdir=infra output -raw api_key)

curl -sS -H "x-api-key: $API_KEY" "$API_URL/health"
# -> {"status":"ok"}

curl -sS -H "x-api-key: $API_KEY" "$API_URL/hello?name=Irvi"
# -> {"message":"Hello, Irvi!"}
```

---

## üîí Seguran√ßa (o que j√° tem hoje)
**API & rede**
- **API Key obrigat√≥ria** em todos os m√©todos (Usage Plan aplicado).
- **Somente HTTPS** no API Gateway (TLS obrigat√≥rio).

**Identidade & acesso**
- **OIDC** na pipeline ‚Üí **credenciais tempor√°rias** (nada de chaves fixas).
- **Least-Privilege**: permiss√µes limitadas ao bucket/tabela/recursos necess√°rios.
- **`iam:PassRole`** somente para `challenge-api-role`.
- **Mascaramento** da `api_key` nos logs da Action.

**State protegido**
- **S3 com versionamento + SSE (AES-256)**.
- **DynamoDB** como lock (evita corridas e corrup√ß√£o).

> Pr√≥ximos passos de hardening: WAF no API Gateway, alarms (5xx/Throttles), rota√ß√£o das API Keys, authorizer JWT (Cognito) e KMS gerenciado se necess√°rio.

---

## ‚è±Ô∏è Limites de uso (throttling & quotas) ‚Äî explicado simples
Pensa em duas ‚Äúcatracas‚Äù:  
1) **Do Stage/Method** (n√≠vel da API como um todo).  
2) **Do Usage Plan** (n√≠vel de cada API Key).  

O **limite que vale** para um cliente √© o **menor** dos dois.

**Valores padr√£o neste projeto:**
- **Throttling stage/method:** 100 req/s com **burst** 50 (picos curtos permitidos).  
- **Throttling por API Key:** 100 req/s com **burst** 50.  
- **Quota por API Key:** 10.000 req **por m√™s**.  

Se passar do limite: **HTTP 429 ‚Äì Too Many Requests**. Tente de novo com **exponential backoff** (esperas crescentes + aleat√≥rio).

**Onde mudar isso no c√≥digo:**
- `infra/modules/apigw-rest/main.tf`
  - `aws_api_gateway_method_settings "all"` ‚Üí `throttling_rate_limit`, `throttling_burst_limit`
  - `aws_api_gateway_usage_plan "plan"` ‚Üí `throttle_settings{}` e `quota_settings{}`

**Como ver o 429 na pr√°tica (teste):**
```bash
API_URL=$(terraform -chdir=infra output -raw api_url)
API_KEY=$(terraform -chdir=infra output -raw api_key)

# 200 chamadas concorrentes (agrupa por status)
seq 1 200 | xargs -n1 -P50 -I{}   curl -s -o /dev/null -w "%{http_code}
"   -H "x-api-key: $API_KEY" "$API_URL/health" | sort | uniq -c
```

---

## üêõ Erros que vimos (e como consertamos)
- **409 ‚Äì `Lambda CreateFunction`: j√° existe**
  - **Causa**: a fun√ß√£o existia, mas o **state** da pipeline estava em outro **key**.
  - **Fix**: importar a fun√ß√£o no state (`terraform import ‚Ä¶ challenge-api`) e migrar para `infra/terraform.tfstate`. Dica: **import declarativo** no c√≥digo.

- **403 ‚Äì `S3 HeadObject Forbidden` no init**
  - **Causa**: bucket errado/typo **ou** falta de permiss√£o na role OIDC.
  - **Fix**: corrigir policy e secrets (`TF_STATE_BUCKET/KEY`) e checar com `head-bucket`/`list-objects`.

- **DynamoDB `ConditionalCheckFailed` (lock preso)**
  - **Causa**: cadeado do state ficou √≥rf√£o numa migra√ß√£o.
  - **Fix**: `terraform force-unlock -force <LOCK_ID>` e repetir a migra√ß√£o.

- **`API Gateway BadRequest: Invalid ARN`**
  - **Causa**: `var.region` vazio ‚Üí ARN sem regi√£o e URL com `execute-api..amazonaws.com`.
  - **Fix**: passar `-var="region=us-east-1"` ou usar `data.aws_region.current.name` no m√≥dulo.

- **409 ‚Äì `Lambda AddPermission`: statement id existe**
  - **Causa**: j√° havia `AllowAPIGatewayInvoke` na fun√ß√£o.
  - **Fix**: `terraform import module.apigw_rest.aws_lambda_permission.allow_apigw challenge-api/AllowAPIGatewayInvoke` (ou versionar o `statement_id` por ambiente).

- **Smoke falhou mesmo com resposta OK**
  - **Causa**: `grep` era r√≠gido (`"Hello, CI"`) e a resposta tinha `!`.
  - **Fix**: validar com `jq` ou regex tolerante.

> Prote√ß√£o permanente: um step que falha se o plan tentar **criar** a Lambda (state divergente).

---

## üóÇÔ∏è Estrutura do projeto (resumo)
```
desafio-entrevista/
‚îú‚îÄ app/
‚îÇ  ‚îú‚îÄ api.py                 # FastAPI app + Mangum handler
‚îÇ  ‚îî‚îÄ requirements.txt
‚îú‚îÄ infra/
‚îÇ  ‚îú‚îÄ backend.tf             # backend S3 + DynamoDB (state remoto)
‚îÇ  ‚îú‚îÄ main.tf                # m√≥dulos: lambda-func e apigw-rest
‚îÇ  ‚îú‚îÄ providers.tf           # provider AWS
‚îÇ  ‚îú‚îÄ variables.tf           # region, lambda_name, package_zip...
‚îÇ  ‚îú‚îÄ outputs.tf             # api_url, api_key
‚îÇ  ‚îî‚îÄ modules/
‚îÇ     ‚îú‚îÄ lambda-func/
‚îÇ     ‚îÇ  ‚îú‚îÄ main.tf
‚îÇ     ‚îÇ  ‚îú‚îÄ variables.tf
‚îÇ     ‚îÇ  ‚îî‚îÄ outputs.tf
‚îÇ     ‚îî‚îÄ apigw-rest/
‚îÇ        ‚îú‚îÄ main.tf
‚îÇ        ‚îú‚îÄ variables.tf
‚îÇ        ‚îî‚îÄ outputs.tf
‚îú‚îÄ scripts/
‚îÇ  ‚îî‚îÄ package.sh
‚îî‚îÄ .github/workflows/
   ‚îî‚îÄ deploy.yaml
```

---

## üìå Pr√≥ximos passos legais
- Versionar/alias da Lambda (deploys 0-downtime).
- Observabilidade melhor (m√©tricas + alarmes).
- Stage `dev` com **Usage Plans** separados.
- Auth ‚Äúde verdade‚Äù (JWT/Cognito) quando necess√°rio.

---

## üìú Licen√ßa
Este reposit√≥rio √© um desafio t√©cnico. Ajuste a licen√ßa conforme necessidade (MIT, Apache-2.0, etc.).
